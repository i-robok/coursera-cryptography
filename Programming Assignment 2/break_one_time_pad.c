#include <stdio.h>
#define KEY_LENGTH 31

#define SPACE 0x20
#define LETTER_XOR_SPACE_MARK 0x40

/*
    https://www.coursera.org/learn/cryptography/supplement/3Iajv/programming-assignment-2

    "Below are 7 ciphertexts, each of which was generated by encrypting some 31-character ASCII 
    plaintext with the one-time pad using the same key (code for the encryption program used is 
    given below). Decrypt them and recover all 7 plaintexts, each of which is a grammatically 
    correct English sentence."
*/

int propagate_plain_text(int nof_ciphers, unsigned char cipher_text[7][KEY_LENGTH], unsigned char plain_text[7][KEY_LENGTH])
{
    // Apply discovered letter/space to the rest of the ciphers.
    int i, j, k;
    unsigned char ci_xor_ck;

    for(i=0; i < nof_ciphers; i++) {
        for (j=0; j < KEY_LENGTH; j++) {
            if (plain_text[i][j] != 0x00) {
                for (k=0; k < nof_ciphers; k++) {
                    if (k != i && plain_text[k][j] == 0x00) {
                        ci_xor_ck = cipher_text[i][j] ^ cipher_text[k][j];
                        plain_text[k][j] = plain_text[i][j] ^ ci_xor_ck;
                    }
                }
            }
        }
    }
}

int print_plain_text(int nof_ciphers, unsigned char plain_text[7][KEY_LENGTH])
{
    int i, j;
    for (i=0; i < nof_ciphers; i++) {
        for (j=0; j < KEY_LENGTH; j++) {
            if (plain_text[i][j] != 0x00) {
                printf("%c", plain_text[i][j]);
            }
            else {
                printf("?");
            }
        }
        printf("\n");
    }
    printf("0123456789012345678901234567890\n");
    printf("          1         2         3\n");
}


int main() {
    FILE *fpIn;
    int nof_ciphers, i, j, k;

    unsigned char cipher_text[7][KEY_LENGTH];
    unsigned char plain_text[7][KEY_LENGTH];

    // Get cipher texts from the file
    fpIn = fopen("ctexts-original.txt", "r");
    
    unsigned char byte;
    i=0;
    j=0;
    while (fscanf(fpIn, "%2hhx", &byte) != EOF) {
        cipher_text[i][j++] = byte;

        printf("%02x.", byte);
        if (j % 10 == 0) {
            printf("-");
        }
        if (j == KEY_LENGTH) {
            i++;
            j=0;
            printf("\n");
        }
    }
    fclose(fpIn);
    nof_ciphers = i;

    // Fill plain_text with zeroes.
    for (i=0; i < nof_ciphers; i++) {
        for (j=0; j < KEY_LENGTH; j++) {
            plain_text[i][j] = 0x00;
        }
    }

    // Find spaces or his partner letters.
    unsigned char ci_xor_cj, ci_xor_ck;
    int next_i;
    for(i=0; i < nof_ciphers; i++) {
        next_i = (i+1) % nof_ciphers;
        for (j=0; j < KEY_LENGTH; j++) {
            if (plain_text[i][j] == 0x00) {
                ci_xor_cj = cipher_text[i][j] ^ cipher_text[next_i][j];

                // Is this (letter xor space)?
                if (ci_xor_cj & LETTER_XOR_SPACE_MARK) {

                    // find another cipher to verify which row contains the space
                    for (k=0; k < nof_ciphers && plain_text[i][j] == 0x00; k++) {
                        if (k != i && 
                            k != next_i && 
                            cipher_text[k][j] != cipher_text[next_i][j] && 
                            cipher_text[k][j] != cipher_text[i][j]) {
                            ci_xor_ck = cipher_text[i][j] ^ cipher_text[k][j];

                            if (ci_xor_ck & LETTER_XOR_SPACE_MARK) {
                                plain_text[i][j] = SPACE;
                            }
                            else {
                                plain_text[i][j] = SPACE ^ ci_xor_cj;
                            }
                        }
                    }

                }
            }
        }
    }

    // Print parcial advances.
    print_plain_text(nof_ciphers, plain_text);

    // Propagate the plain text.
    propagate_plain_text(nof_ciphers, cipher_text, plain_text);

    // Print parcial advances.
    print_plain_text(nof_ciphers, plain_text);

    // Add some guesses
    plain_text[0][0] = 'I';
    plain_text[0][6] = 'l';
    plain_text[0][8] = 'n';
    plain_text[0][10] = 'i';
    plain_text[0][17] = 'e';
    plain_text[0][20] = 'e';
    plain_text[0][29] = 'n';
    plain_text[0][30] = '.';

    // Propagate the plain text.
    propagate_plain_text(nof_ciphers, cipher_text, plain_text);

    // Print parcial advances.
    print_plain_text(nof_ciphers, plain_text);

    return 0;
}

